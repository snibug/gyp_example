#!/usr/bin/env python
# Copyright 2012 Google Inc. All Rights Reserved.
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#     http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

# for right now, prerequisites are:
# - you installed GraphViz for Windows and added the bin/ directory to your PATH
# - you have run gyp_lb
# - you then opened lb_shell.sln and did a build or rebuild all PS3_Debug
# now you can run this python script without argument, it will generate
# the build report in out/build_report_<YYYY_MM_DD_HH_MM> directory


import codecs
import datetime
import depends_dict  # generated by gyp
import operator
import os
import re
import shutil
import subprocess

script_dir = os.path.abspath(os.path.dirname(__file__))
root_dir = os.path.abspath(os.path.join(script_dir, '../../'))

def windows_path(cygwin_path):
  sp = subprocess.Popen(['cygpath', '-m', cygwin_path], stdout=subprocess.PIPE)
  return sp.stdout.readline().rstrip()

def tally_sizes(lib_folder, elf_path):
  mappings = {}
  sums = {}

  # this regex matches the output format of ps3bin:
  # ADDR TYPE SIZE NAME
  # 0x0000000000000008 d 0x0008 check_type1_format
  symbol_regex = re.compile(r'(0x[0-9A-Fa-f]+) (.) (0x[0-9A-Fa-f]+) (.+)\r\n')

  # compute windows_paths for our inputs:
  lib_folder = windows_path(lib_folder)
  elf_path = windows_path(elf_path)

  # get all libraries
  files = os.listdir(lib_folder)
  for lib in files:
    lib_path = os.path.join(lib_folder, lib)
    lib = lib.replace(".lib", "") # trim extension
    sums[lib] = 0
    # dump symbols for this library in concise form (-c)
    sp = subprocess.Popen(['ps3bin', '-dsy', '-c', lib_path], stdout=subprocess.PIPE)
    for line in sp.stdout:
      matches = symbol_regex.match(line)
      if matches:
        # map this symbol name to the library it comes from
        mappings[matches.group(4)] = lib

  # dump symbols for the executable in concise form (-c)
  sp = subprocess.Popen(['ps3bin', '-dsy', '-c', elf_path], stdout=subprocess.PIPE)
  for line in sp.stdout:
    matches = symbol_regex.match(line)
    if matches:
      # track the size of this symbol to the library it comes from
      lib = mappings.get(matches.group(4))
      # some size in the binary come from the linker, in which case lib is None
      if lib:
        sums[lib] += int(matches.group(3), 16)

  return sums

def traverse_tree(gv_file, dd, target, visited = None):
  if visited is None: visited = set()

  visited.add(target)

  target_deps = dd[target]
  for dep in target_deps:
    gv_file.write('  %d -> %d;\n' % (hash(target), hash(dep)))

  for dep in target_deps:
    if dep not in visited:
      traverse_tree(gv_file, dd, dep, visited)

def main():
  # make sure we are in the script dir
  os.chdir(script_dir)
  dd = depends_dict.depends_dict
  # save this time for later when we generate the HTML
  now = datetime.datetime.today()
  # make our output directory as a string of today's date and time
  outdir_name = now.strftime("out/build_report_%Y_%m_%d_%H_%M")
  outdir_path = os.path.join(root_dir, outdir_name)
  os.mkdir(outdir_path)

  # __LB_PS3__FIX_ME__ : make this thing capable of handling all build types.
  build_output_path = os.path.join(root_dir, 'out', 'lb_shell', 'PS3_Debug')

  # build reverse dependencies
  revdeps = {}
  for target, dependencies in dd.iteritems():
    for depends in dependencies:
      if not revdeps.has_key(depends):
        revdeps[depends] = []
      revdeps[depends].append(target)

  # now compute binary size per library
  sizes = tally_sizes(os.path.join(build_output_path, 'lib'), os.path.join(build_output_path, 'lb_shell.ppu.self'))

  # uses the same keys as dd, stores a tuple (errors, warnings) for each product
  build_stats = {}

  total_errors = 0
  total_warnings = 0
  total_targets = len(dd)
  targets_broken = 0
  targets_building = 0
  prunable_targets = 0
  empty_targets = 0

  # make our output .gv file
  gv_path = os.path.join(outdir_path, 'lb_shell.gv')
  gv_file = open(gv_path, 'w')
  # and start the graph
  gv_file.write('digraph G {\n')

  # we need to build a list of individual targets within files
  # this has key of filepaths and value of list of (target_name, target_hash)
  subgraphs = {}

  # first gather our BuildLogs by copying them and renaming them to their hashes
  # also fill out the build_stats dictionary with target
  for target in dd.keys():
    [gyp_file_name, target_name, product_name] = target.split(':')
    # compute and store target hash
    target_hash = str(hash(target))
    # use that for the build log path
    build_log_path = os.path.join(build_output_path, target_name, 'BuildLog.htm')

    # does this file exist?
    if os.path.exists(build_log_path):
      copied_log_name = target_hash + '.html'
      copied_log_path = os.path.join(outdir_path, copied_log_name)
      # first copy it to a unique filename in our output dir
      shutil.copyfile(build_log_path, copied_log_path)
      # now open our unicode copied file
      f = codecs.open(copied_log_path, "r")
      # jump to the last couple kilobytes of the file
      f.seek(-1024, os.SEEK_END)
      build_log_tail = f.read()
      # look for the errors and warnings count at the bottom
      match = re.search(r'%s - (?P<errors>\d+) error[(]s[)], '
                        r'(?P<warnings>\d+) warning[(]s[)]' % target_name,
          build_log_tail)

      if match:
        errors = int(match.group('errors'))
        warnings = int(match.group('warnings'))
        total_errors += errors
        total_warnings += warnings
        # add the stats to the dict
        build_stats[target] = (errors, warnings)
      else:
        # don't count already built targets as broken
        match = re.search('%s - up-to-date' % target_name, build_log_tail)
        if match:
          build_stats[target] = (-1, -1)

    # build subgraphs this time
    if gyp_file_name not in subgraphs:
      subgraphs[gyp_file_name] = []
    subgraphs[gyp_file_name].append((target_name, target_hash, product_name))

    # in any event we know enough to describe the node to the dot file
    # a couple of cases for nodes
    if build_stats.has_key(target):
      # we were able to find the build log, so we color-code red/yellow/green
      # based on errors/warnings/clean and make a solid line
      style = 'solid'
      (errors, warnings) = build_stats[target]
      size = sizes.get(product_name)
      if errors == -1 and warnings == -1:
        targets_building += 1
        color = "black"
      elif size == 0:
        targets_building += 1
        prunable_targets += 1
        color = 'blue'
      elif errors == 0 and warnings == 0:
        targets_building += 1
        color = 'green'
      elif errors == 0:
        targets_building += 1
        color = 'yellow'
      else:
        targets_broken += 1
        color = 'red'
    else:
      color = "black"
      style = 'dashed'
      empty_targets += 1

    gv_file.write('  %s [ label="%s" color="%s" style="%s" URL="%s" shape="box"];\n' %
        (target_hash, target_name, color, style, '#' + target_hash))

  # once again through the graph to output the actual graph to the .gv
  # do this by traversing outward from lb_shell, thus only adding things in its deps tree
  traverse_tree(gv_file, dd, 'projects/lb_shell.gyp:lb_shell:lb_shell')

  # and iterate through the subgraph dict to set up the subgraphs
  for file_name, nodes in subgraphs.iteritems():
    gv_file.write('  subgraph "cluster%d" {\n' % hash(file_name))
    gv_file.write('    label="%s";\n' % os.path.basename(file_name))
    for (_, hash_val, _) in nodes:
      gv_file.write('    %s;\n' % hash_val)
    gv_file.write('  }\n')

  # now we can close our graph file
  gv_file.write('}\n')
  gv_file.close()

  # and call dot (assumed to be on the command line...) to generate the
  # image map and image files.  We make three quick calls to cygpath here to get
  # windows paths for the files, as dot.exe is a windows exe not a cygwin one
  subprocess.call('dot -Tcmapx -o"`cygpath -w %s`" -Tpng -o"`cygpath -w %s`" -Kfdp "`cygpath -w %s`"' % (
      os.path.join(outdir_path, 'lb_shell.cmapx'),
      os.path.join(outdir_path, 'lb_shell.png'),
      gv_path), shell=True)

  # alright now we're cooking let's generate some HTML!
  report_file = open(os.path.join(outdir_path, 'index.html'), 'w')
  report_file.write(
"""
<html>
<head>
<title>LBPS3 Build Report %s</title>
<body>
<h1 align="center">LBPS3 Build Report %s</h1>
<h2>Build Summary</h2>
<table border="1">
  <tr><td>Targets Building:</td><td>%d</td></tr>
  <tr><td>Targets Broken:</td><td>%d</td></tr>
  <tr><td>Empty Targets:</td><td>%d</td></tr>
  <tr><td>Prunable Targets:</td><td>%d</td></tr>
  <tr><td>Total Targets:</td><td>%d</td></tr>
  <tr><td>Total Errors:</td><td>%d</td></tr>
  <tr><td>Total Warnings:</td><td>%d</td></tr>
  <tr>
</table>
""" % (
      now.strftime('%Y-%m-%d %H:%M'),
      now.strftime('%Y-%m-%d %H:%M'),
      targets_building,
      targets_broken,
      empty_targets,
      prunable_targets,
      total_targets,
      total_errors,
      total_warnings))

  # close the table off
  report_file.write('</table>\n\n')

  # write the binary size table
  report_file.write('<h2>Ten Largest Libraries</h2>\n')
  report_file.write('<h4>These are statistics about how much each library contributes to the total executable size.</h4>\n')
  report_file.write('<table border="1">\n')
  report_file.write('<tr><th>Library</th><th>Size</th><th>% of Executable</th></tr>\n')
  total_size_in_bytes = sum(sizes.itervalues())
  total_size_in_mb = float(total_size_in_bytes) / (1024.0 * 1024.0)
  for (lib, size_in_bytes) in sorted(sizes.iteritems(), key=operator.itemgetter(1), reverse=True)[:10]:
    try:
      percent = 100.0 * float(size_in_bytes) / float(total_size_in_bytes)
    except:
      percent = 0.0
    size_in_mb = float(size_in_bytes) / (1024.0 * 1024.0)
    report_file.write('<tr><td>%s</td><td>%.3f MB</td><td>%.3f %%</td></tr>' % (lib, size_in_mb, percent))
  report_file.write('<tr><th>Total Executable Size</th><td>%.3f MB</td><td></td></tr>' % total_size_in_mb)
  report_file.write('</table>\n\n')

  # open the image map and write it to
  cmapx_file = open(os.path.join(outdir_path, 'lb_shell.cmapx'))
  # write it into the report
  report_file.write(cmapx_file.read())
  # and close the map file
  cmapx_file.close()

  # now a bit more static HTML, linking in the image and starting the targets table
  report_file.write(
"""
<h2>Dependencies Diagram</h2>
<p>Click on a build target to jump to a list of dependencies for that target.
Targets built with no errors or warnings and providing symbols are green, targets
built but not contributing symbols are blue, targets built with no errors
but warnings are yellow, targets failing to build are red. Targets that don't
actually include any source to compile have had their dependencies omitted from
the graph for clarity and appear with a dashed outline.  You can still click on
these "empty" targets to get a list of their dependencies.</p>

<img src="lb_shell.png" usemap="G">

<h2>Target Information</h2>
<table border="1">
<tr><th>File</th> <th>Target (click for build log)</th> <th>Size</th> <th>Errors</th> <th>Warnings</th> <th>Dependencies</th> <th>Reverse Dependencies</th></tr>
""")
  # build our all-powerful table
  altcolor = False
  for file_name in sorted(subgraphs.iterkeys()):
    nodes = subgraphs[file_name]
    if altcolor:
      rowcolor = '#cccccc'
    else:
      rowcolor = '#ffffff'
    altcolor = not altcolor
    firstline = True
    for (target_name, target_hash, product_name) in nodes:
      if firstline:
        rowstring = '<tr bgcolor="%s"><td rowspan="%d" valign="top">%s</td>' % (
            rowcolor, len(nodes), file_name)
        firstline = False
      else:
        rowstring = '<tr bgcolor="%s">' % rowcolor
      full_target_name = file_name + ':' + target_name + ':' + product_name
      # for target name see if we need to link to the build_log
      if full_target_name in build_stats:
        (errors, warnings) = build_stats[full_target_name]
        if errors == -1:
          errors = "unknown"
          errorcolor = rowcolor
        elif errors == 0:
          errorcolor = rowcolor
        else:
          errorcolor = '#ff7777'

        if warnings == -1:
          warnings = "unknown"
          warningcolor = rowcolor
        elif warnings == 0:
          warningcolor = rowcolor
        else:
          warningcolor = '#ffff77'

        size = sizes.get(target_name)
        if size == 0:
          sizecolor = '#7777ff'
        else:
          sizecolor = rowcolor

        rowstring += '<td><a href="%s.html" name="%s" target="_blank">%s</a></td>' % (
            target_hash,
            target_hash,
            target_name)
        rowstring += '<td bgcolor="%s">%s</td><td bgcolor="%s">%s</td><td bgcolor="%s">%s</td>' % (
            sizecolor,
            '--' if size is None else '%d bytes' % size,
            errorcolor,
            errors,
            warningcolor,
            warnings)
      else:
        rowstring += '<td><a name="%s">%s</a></td><td>--</td><td>--</td><td>--</td>' % (target_hash, target_name)

      # now we do the dependencies, an unordered (for now) list of links to other anchors in the file
      rowstring += '<td>'
      for depends in sorted(dd[full_target_name]):
        rowstring += '<a href="#%d">%s</a> ' % (
            hash(depends), os.path.basename(depends).split(':')[1])
      rowstring += '</td>'

      # now we do the reverse dependencies, another unordered list with links
      if revdeps.has_key(full_target_name):
        rowstring += '<td>'
        for depends in sorted(revdeps[full_target_name]):
          rowstring += '<a href="#%d">%s</a> ' % (
              hash(depends), os.path.basename(depends.split(':')[1]))
        rowstring += '</td>'
      else:
        rowstring += '<td/>'

      rowstring += '</tr>\n'
      report_file.write(rowstring)

  # now write the footer info, closes the table, the body, and the html
  report_file.write(
"""
</table>
</body>
</html>
""")
  report_file.close()

if __name__ == '__main__':
  main()
